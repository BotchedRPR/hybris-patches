From ce944e8b0e0f734c59627282b9da6e93c4165309 Mon Sep 17 00:00:00 2001
From: NeKit <nekit1000@gmail.com>
Date: Tue, 7 Apr 2020 02:11:56 +0200
Subject: [PATCH] (halium) reenable SensorService, skip permission check

Needed for platform-api to work as phablet

Change-Id: I077312bbe4f0846ccf5e6514ea45766381e82ddc
---
 cmds/servicemanager/servicemanager.rc    |  5 +++++
 services/sensorservice/SensorService.cpp | 22 ++++++++++++----------
 2 files changed, 17 insertions(+), 10 deletions(-)

diff --git a/cmds/servicemanager/servicemanager.rc b/cmds/servicemanager/servicemanager.rc
index 17e0083..bbd8fbe 100644
--- a/cmds/servicemanager/servicemanager.rc
+++ b/cmds/servicemanager/servicemanager.rc
@@ -42,3 +42,8 @@ service settingsd_HYBRIS /bin/sleep infinity
     socket settingsd stream 0600 radio radio
     class early_hal
     oneshot
+
+service sensorservice /system/bin/sensorservice
+    class main
+    user system
+    group system
diff --git a/services/sensorservice/SensorService.cpp b/services/sensorservice/SensorService.cpp
index 1c3e943..558acb7 100644
--- a/services/sensorservice/SensorService.cpp
+++ b/services/sensorservice/SensorService.cpp
@@ -1543,9 +1543,9 @@ status_t SensorService::flushSensor(const sp<SensorEventConnection>& connection,
     return err;
 }
 
-bool SensorService::canAccessSensor(const Sensor& sensor, const char* operation,
-        const String16& opPackageName) {
-    const String8& requiredPermission = sensor.getRequiredPermission();
+bool SensorService::canAccessSensor(const Sensor& /*sensor*/, const char* /*operation*/,
+        const String16& /*opPackageName*/) {
+    /*const String8& requiredPermission = sensor.getRequiredPermission();
 
     if (requiredPermission.length() <= 0) {
         return true;
@@ -1576,7 +1576,7 @@ bool SensorService::canAccessSensor(const Sensor& sensor, const char* operation,
                     operation, sensor.getName().string(), opCode);
             return false;
         }
-    }
+    }*/
 
     return true;
 }
@@ -1710,25 +1710,27 @@ void SensorService::UidPolicy::updateOverrideUid(uid_t uid, bool active, bool in
     }
 }
 
-bool SensorService::UidPolicy::isUidActive(uid_t uid) {
+bool SensorService::UidPolicy::isUidActive(uid_t /*uid*/) {
     // Non-app UIDs are considered always active
-    if (uid < FIRST_APPLICATION_UID) {
+    /*if (uid < FIRST_APPLICATION_UID) {
         return true;
     }
     Mutex::Autolock _l(mUidLock);
-    return isUidActiveLocked(uid);
+    return isUidActiveLocked(uid);*/
+    return true;
 }
 
-bool SensorService::UidPolicy::isUidActiveLocked(uid_t uid) {
+bool SensorService::UidPolicy::isUidActiveLocked(uid_t /*uid*/) {
     // Non-app UIDs are considered always active
-    if (uid < FIRST_APPLICATION_UID) {
+    /*if (uid < FIRST_APPLICATION_UID) {
         return true;
     }
     auto it = mOverrideUids.find(uid);
     if (it != mOverrideUids.end()) {
         return it->second;
     }
-    return mActiveUids.find(uid) != mActiveUids.end();
+    return mActiveUids.find(uid) != mActiveUids.end();*/
+    return true;
 }
 
 }; // namespace android
-- 
2.26.0

